1. General Settings: EMIN

integrator = steep
 -> mm.LocalEnergyMinimizer.minimize()

emtol = 1000.0      # tolerance 
 -> mm.LocalEnergyMinimizer.minimize(system, tolerance=1000 * mm.unit.kilojoule_per_mole / mm.unit.nanometer)

emstep = 0.01
 -> Minimizer adjusts the step automatically 

nstenergy = 500     # use reporters to set this
 -> simulation.reporters.append(mm.app.StateDataReporter('output.log', 500, step=True, potentialEnergy=True))


nsteps = 100        # set in the minimize function 
 -> mm.LocalEnergyMinimizer.minimize(system, maxIterations=100)

ld_seed = -1
 -> simulation.context.setParameter('randomSeed', 12345)

 continueation = no 
  -> Managed by whether we load a checkpoint or initialize the system from scratch 



2. Force Field and Cutoff Settings: EMIN

constraints = h-bonds       # specify when creating the `System` object 
 -> system = mm.System()
    constraints = mm.app.HBonds

rcoulomb = 1.2, rvdw = 1.2      # cutoff distances for electrostatistics and van der Waals interactions. 
                                # set when we create `NonboundedForce`
 -> nonbonded_force.setCutoffDistance(1.2 * mm.unit.nanometers)

vdw-modifier = Force-switch, rvdw_switch = 1.0    # openmm does not have an exact equivalent of the force-switch modifier 
                                                  # We can set the switching distance for nonbounded interactions. 
 -> nonbonded_force.setUseSwitchingFunction(True)
    nonbonded_force.setSwitchingDistance(1.0 * mm.unit.nanometers)

DispCorr = no   # Not applied directly in openMM, if we are using charmm force field, the dispersion corrections are usually accounted for by the force field itself. 

coulombtype = PME   # use `NonboundedForce` to appoly Particle Mesh Ewald (PME) for long-range electrostatics. 
 -> nonbounded_force.setNonboundedMethod(mm.NonboundedForce.PME)

fourierspacing = 0.15   # setting the grid spacing for the PME calculation 
 -> nonbounded_force.setEwaldErrorTolerance(0.0001) # controls PME accuracy. 




          1. General Settings: MD

integrator = md   # use an appropriate integrator 
                  # mm.LangevinIntegrator for constant temperature (with velocity rescaling)
                  # mm.VerletIntegrator for NVE
 -> integrator = mm.LangevinIntegrator(300*mm.unit.kelvin, 1.0/mm.unit.picosecond, 0.002*mm.unit.picoseconds)

dt = 0.002    # time step is set when we create the integrator in OpenMM (above)

nsteps = 500000   # simulation steps 
 -> simulation.step(500000)

pbc = xyz   # periodic boundary conditions. Automatically applied in openmm (based on the systems box dimensions)

continuation = yes
 -> simulation.loadCheckpoint('checkpoint.chk')



          2. Output Controls: MD

nstxout = 0, nstvout = 0, nstfout = 0   # these are controlled using reporters in openMM. 
                                        # If you dont want to write these data points, dont add the corresponding reporter. 

nstlog = 50   # Use `StateDataReporter` to log energy and other state information. 
 -> simulation.reporters.append(mm.app.StateDataReporter('output.log', 50, step=True, potentialEnergy=True, temperature=True))

nstenergy = 500   # similar to `nstlog` above

nstxout-compressed = 2500   # controls the output frequency for trajectory data.
                            # analagous to `DCDReporter` and `PDBReporter` in OpenMM
 -> simulation.reporters.append(mm.app.DCDReporter('trajectory.dcd', 2500))

ld-seed = -1    # Typically set during the initialization. 



          3. Pressure Coupling: MD

pcoupl = C-rescale, pcoupltype = isotropic    # In OpenMM we use the `MonteCarloBarostat` for isotropic pressure coupling. 
 -> barostat = mm.MonteCarloBarostat(1.0*mm.unit.atmospheres, 300*mm.unit.kelvin, 25)
    system.addForce(barostat)

tau_p = 5.0   # in OpenMM the coupling time is not set directly; instead the freq. of barostat updates is set when you init. the `MonteCarloBarostat`

ref_p = 1.0   # reference pressure set in the `MonteCarloBarostat`

compressibility = 4.5e-5    # In OpenMM, water's compressibility is implicit in the pressure coupling method used (you don't set this directly)

refcoord_scaling = com    #  OpenMM handles coordinate scaling internally during pressure coupling.



          4. Temperature Coupling: MD

tcoupl = V-rescale    # The `LangevinIntegrator` effectively serves the same purpose as the velocity-rescale thermostat. 

tc-grps = system    # In OpenMM, the thermostat applies to the entire system unless otherwise specified.

tau_t = 1.0   # The friction coefficient in the `LangevinIntegrator` corresponds to 1/tau_t.
 -> integrator = mm.LangevinIntegrator(300*mm.unit.kelvin, 1.0/mm.unit.picosecond, 0.002*mm.unit.picoseconds)

ref_t = 300   # This is the target temperature, set in the LangevinIntegrator.



          5. Force Field Parameters: MD

constraints = h-bonds   # set when adding constraints to the system. 
 -> system.addForce(mm.HarmonicBondForce())

rcoulomb = 1.2, rvdw = 1.2    # cutoff distances for electrostatic and van der waals interactions. 
 -> nonbonded_force.setCutoffDistance(1.2 * mm.unit.nanometers)

vdw-modifier = Force-switch, rvdw_switch = 1.0    # OpenMM supports switching functions for nonbounded interactions. 
 -> nonbonded_force.setUseSwitchingFunction(True)
    nonbonded_force.setSwitchingDistance(1.0 * mm.unit.nanometers)

DispCorr = no   # see EMIN

coulombtype = PME   # see EMIN

fourierspacing = 0.15   # see EMIN


          1. NPT 

define = -DPOSRES       # Position restraints can be applied by adding a restraint force 
                        # to specific atoms in my system using `CustomBondForce` or `HarmonicBondForce` 
                        # to keep certain atoms fixed or restrained to their initial positions 

Example: 

from simtk import openmm as mm
from simtk import unit

# Assuming `positions` is a list of Vec3 coordinates for your atoms
restraint_force = mm.CustomExternalForce('0.5*k*(x-x0)^2 + 0.5*k*(y-y0)^2 + 0.5*k*(z-z0)^2')
restraint_force.addPerParticleParameter('k')
restraint_force.addPerParticleParameter('x0')
restraint_force.addPerParticleParameter('y0')
restraint_force.addPerParticleParameter('z0')

k_restraint = 1000.0 * unit.kilojoule_per_mole / unit.nanometer**2  # Force constant

for i, pos in enumerate(positions):
    restraint_force.addParticle(i, [k_restraint, pos[0], pos[1], pos[2]])

system.addForce(restraint_force)




          1. NVT

gen_vel = yes   # if you want to generate velocities according to a maxwell-boltzmann distribution, you can use this
 -> simulation.context.setVelocitiesToTemperature(300*mm.unit.kelvin, randomSeed=None)

gen_temp = 300    # temperature for the velocity distribution, specified in the setVelocitiesToTemperature() Method 

gen_seed = -1     # wet the random seed manually, if you use None, it will generate a random seed. 
 -> simulation.context.setVelocitiesToTemperature(300*mm.unit.kelvin, randomSeed=12345)
